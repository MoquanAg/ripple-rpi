# Phase 2.5 Safety Testing Design: Critical Safety & Edge Cases

**Date:** 2026-01-30
**Issue:** MOQ-79 Phase 2.5
**System Value:** Â¥100,000 per device
**Goal:** Implement comprehensive safety and edge case tests to prevent crop damage and equipment failure

## Overview

Phase 2.5 adds **35 critical safety tests** to protect high-value fertigation systems from:
- Sensor failures and invalid data
- Overdosing from stuck sensors or runaway pumps
- Multi-sensor failures causing dangerous states
- Invalid configurations
- Concurrent scheduling conflicts
- Crash recovery edge cases

**Urgency:** These tests are REQUIRED before production deployment. The current 49 tests validate happy paths, but Â¥100,000 devices require comprehensive failure mode coverage.

## Safety Architecture (3 Layers)

### Layer 1: Sensor Data Validation
Prevent bad inputs from triggering dangerous actions.

### Layer 2: Overdose Prevention
Prevent crop damage from excessive dosing.

### Layer 3: System Safety
Prevent operational failures and ensure safe recovery.

---

## Safety Requirements

### 1. Sensor Validation Bounds

**EC Sensor:**
- Min valid: 0.01 mS/cm (below = disconnected/broken/empty tank)
- Max valid: 3.0 mS/cm (hardware sensor limit)
- Max change per cycle: Â±0.5 mS/cm (larger = noise/error)
- Invalid values: NaN, infinity, negative â†’ reject

**pH Sensor:**
- Min valid: 4.0
- Max valid: 9.0
- Max change per run: Â±0.5 (larger = noise/error)
- Invalid values: NaN, None â†’ reject

**Water Level Sensor:**
- Min valid: 0%
- Max valid: 100%
- No cycle-to-cycle change checking (self-contained ball valve system)
- **Refill timeout:** If level low AND no rise after 60 minutes â†’ alert
  - Possible causes: outlet valve stuck open, tank leak, ball valve broken

### 2. Overdose Prevention

**Dosing Pump Timeout (CRITICAL):**
- **Nutrient pumps A/B/C: Max 30 seconds continuous** â†’ emergency shutoff
- **pH up/down pumps: Max 30 seconds continuous** â†’ emergency shutoff
- **Other pumps (mixing, recirculation, water injection): NO timeout** (designed for continuous operation)
- **Sprinklers: Timeout per device.conf** (configurable)

**Daily Runtime Limits:**
- **Max 60 minutes total dosing pump runtime per 24 hours**
- Tracks accumulated runtime for all dosing events
- Prevents overdose even if sensors malfunction
- Persists across system restarts

**Stuck Sensor Detection:**
- **EC: If no increase after 1 minute total pump runtime** â†’ stop dosing, alert
- **pH: If no change after 1 minute total pump runtime** â†’ stop dosing, alert
- Based on accumulated runtime vs. sensor response (not cycle count)
- Detects faulty sensors that return stale/fixed values

**Relay State Verification:**
- After sending pump OFF command â†’ verify relay actually opened
- If relay still reads ON â†’ emergency shutdown
- Applies to all relay-controlled devices

### 3. Multi-Sensor Failure Response

**Fail-Safe Shutdown:**
- If 2+ sensors invalid simultaneously â†’ stop ALL dosing
- Trigger emergency flag
- Log failure details
- Require manual intervention to restart
- **Philosophy:** "Better to under-dose for hours than overdose for minutes"

### 4. Invalid Configuration Handling

**Config Validation on Startup:**
- Negative durations â†’ use default 00:00:00
- Invalid ABC ratio (negative, extreme values) â†’ use default 1:1:0
- EC target < 0 or > 3.0 â†’ use default 1.2 mS/cm
- pH target < 4.0 or > 9.0 â†’ use default 6.5
- Malformed values â†’ safe defaults
- **Log all validation errors** but continue running

### 5. Concurrent Scheduling Safety

**Critical Phase Locking:**
- **Critical phase:** Dosing pumps actively running (cannot interrupt)
- **Normal phase:** Waiting between cycles (can preempt)

**Preemption Process (when not locked):**
1. Stop current cycle cleanly
2. Turn pumps OFF (reset to default state)
3. Cancel scheduled jobs
4. Start new cycle from clean state

**Lock Enforcement:**
- New command during critical phase â†’ reject with error
- New command during normal phase â†’ preempt old, start new

### 6. Crash Recovery

**Startup After Crash/Power Loss:**
1. Read device.conf for each pump's default state
2. Force all pumps to configured defaults:
   - Dosing pumps (nutrient, pH) â†’ OFF
   - Mixing pump â†’ ON (if configured)
   - Recirculation pump â†’ ON (if configured)
   - Water injection â†’ check config default
3. Clear all scheduled jobs from SQLite
4. Wait 5 minutes for sensor stabilization
5. Resume normal operation

**Safety First:** Assume worst-case (pumps stuck from crash), reset to known state.

---

## Test File Structure

```
tests/unit/
â”œâ”€â”€ test_startup_initialization.py      âœ… Phase 1 (10 tests)
â”œâ”€â”€ test_nutrient_logic.py               âœ… Phase 2 (21 tests)
â”œâ”€â”€ test_config_loading.py               âœ… Phase 2 (6 tests)
â”œâ”€â”€ test_scheduler_persistence.py        âœ… Phase 2 (5 tests)
â”œâ”€â”€ test_ph_logic.py                     âœ… Phase 2 (4 tests)
â”œâ”€â”€ test_water_level_logic.py            âœ… Phase 2 (3 tests)
â”œâ”€â”€ test_sensor_validation.py            ğŸ†• Phase 2.5 (12 tests)
â”œâ”€â”€ test_overdose_prevention.py          ğŸ†• Phase 2.5 (13 tests)
â””â”€â”€ test_system_safety.py                ğŸ†• Phase 2.5 (10 tests)
```

**Total Tests:** 84 (49 Phase 1+2, 35 Phase 2.5)

---

## Test Details

### File 1: test_sensor_validation.py (12 tests)

#### EC Sensor Validation (5 tests)

**Test 1: EC = 0.0 â†’ Reject (Disconnected)**
```python
def test_ec_zero_rejected():
    assert is_valid_ec(0.0) == False
```

**Test 2: EC = 0.005 â†’ Reject (Below Min)**
```python
def test_ec_below_min_rejected():
    assert is_valid_ec(0.005) == False  # Min is 0.01
```

**Test 3: EC = 5.0 â†’ Reject (Above Max)**
```python
def test_ec_above_max_rejected():
    assert is_valid_ec(5.0) == False  # Max is 3.0
```

**Test 4: EC Changes Â±0.6 â†’ Reject (Noise)**
```python
def test_ec_change_exceeds_threshold_rejected():
    previous_ec = 1.0
    current_ec = 1.6  # Change = +0.6, max allowed = Â±0.5
    assert is_ec_change_valid(previous_ec, current_ec) == False
```

**Test 5: EC = NaN/Infinity â†’ Reject**
```python
@pytest.mark.parametrize("invalid_value", [
    float('nan'),
    float('inf'),
    float('-inf'),
    -1.5,
])
def test_ec_invalid_values_rejected(invalid_value):
    assert is_valid_ec(invalid_value) == False
```

#### pH Sensor Validation (4 tests)

**Test 6: pH = 3.5 â†’ Reject (Below Min)**
```python
def test_ph_below_min_rejected():
    assert is_valid_ph(3.5) == False  # Min is 4.0
```

**Test 7: pH = 10.0 â†’ Reject (Above Max)**
```python
def test_ph_above_max_rejected():
    assert is_valid_ph(10.0) == False  # Max is 9.0
```

**Test 8: pH Changes Â±0.6 â†’ Reject (Noise)**
```python
def test_ph_change_exceeds_threshold_rejected():
    previous_ph = 6.5
    current_ph = 7.2  # Change = +0.7, max allowed = Â±0.5
    assert is_ph_change_valid(previous_ph, current_ph) == False
```

**Test 9: pH = NaN/None â†’ Reject**
```python
@pytest.mark.parametrize("invalid_value", [
    float('nan'),
    None,
    -1.0,
])
def test_ph_invalid_values_rejected(invalid_value):
    assert is_valid_ph(invalid_value) == False
```

#### Water Level Validation (3 tests)

**Test 10: Water Level = -10% â†’ Reject**
```python
def test_water_level_negative_rejected():
    assert is_valid_water_level(-10) == False
```

**Test 11: Water Level = 150% â†’ Reject**
```python
def test_water_level_above_max_rejected():
    assert is_valid_water_level(150) == False  # Max is 100%
```

**Test 12: Water Level Low, No Rise After 60 Min â†’ Alert**
```python
def test_water_level_refill_timeout_triggers_alert(freezegun):
    # Arrange: water level at 20%, refill should be triggered
    with freeze_time("2026-01-30 10:00:00") as frozen_time:
        trigger_water_refill(level=20)

        # Advance 60 minutes
        frozen_time.tick(delta=timedelta(minutes=60))

        # Water level still at 20% (no rise)
        check_result = check_water_refill_progress(current_level=20)

        # Should trigger alert (valve stuck/leak/ball valve broken)
        assert check_result.alert_triggered == True
        assert "refill timeout" in check_result.alert_message.lower()
```

---

### File 2: test_overdose_prevention.py (13 tests)

#### Dosing Pump Timeout (4 tests)

**Test 13: Nutrient Pump Runs 31 Seconds â†’ Emergency Shutoff**
```python
def test_nutrient_pump_timeout_triggers_emergency_shutoff(freezegun, mock_relay):
    # Arrange
    with freeze_time("2026-01-30 10:00:00") as frozen_time:
        start_nutrient_pumps_static()

        # Advance 31 seconds (exceeds 30 sec limit)
        frozen_time.tick(delta=timedelta(seconds=31))

        # Trigger timeout check (failsafe thread)
        check_pump_timeouts()

        # Assert: emergency shutoff triggered
        assert emergency_shutdown_triggered() == True
        assert mock_relay.get_relay_state("NutrientPumpA") == False
```

**Test 14: pH Pump Runs 31 Seconds â†’ Emergency Shutoff**
```python
def test_ph_pump_timeout_triggers_emergency_shutoff():
    # Same pattern as Test 13, for pH up/down pumps
```

**Test 15: Mixing Pump Runs 5 Minutes â†’ No Shutoff**
```python
def test_mixing_pump_no_timeout(freezegun):
    # Arrange: mixing pump configured to run continuously
    with freeze_time("2026-01-30 10:00:00") as frozen_time:
        start_mixing_pump()

        # Advance 5 minutes
        frozen_time.tick(delta=timedelta(minutes=5))
        check_pump_timeouts()

        # Assert: mixing pump still running (no timeout)
        assert mock_relay.get_relay_state("MixingPump") == True
        assert emergency_shutdown_triggered() == False
```

**Test 16: Sprinkler Timeout Per device.conf**
```python
def test_sprinkler_timeout_from_config(mock_config, freezegun):
    # Config: sprinkler_max_runtime = 00:10:00
    mock_config.set_sprinkler_timeout(minutes=10)

    with freeze_time("2026-01-30 10:00:00") as frozen_time:
        start_sprinkler()

        # Advance 11 minutes (exceeds config limit)
        frozen_time.tick(delta=timedelta(minutes=11))
        check_pump_timeouts()

        # Assert: sprinkler stopped
        assert mock_relay.get_relay_state("Sprinkler") == False
```

#### Runtime Limits (3 tests)

**Test 17: Total Runtime Exceeds 60 Min/24h â†’ Refuse Next Cycle**
```python
def test_daily_runtime_limit_prevents_overdose(mock_runtime_tracker):
    # Arrange: already ran 60 minutes today
    mock_runtime_tracker.set_today_runtime(minutes=60)

    # Act: attempt another cycle
    result = can_start_dosing_cycle()

    # Assert: rejected
    assert result == False
    assert "daily runtime limit exceeded" in get_last_error()
```

**Test 18: Runtime Tracking Persists Across Restart**
```python
def test_runtime_tracking_survives_restart(tmp_path):
    # 1. Run pumps for 30 minutes
    run_dosing_cycle(duration_minutes=30)
    save_runtime_data()

    # 2. Simulate restart
    restart_system()

    # 3. Check runtime history restored
    assert get_today_runtime() == 30 * 60  # 1800 seconds
```

**Test 19: Only Count Dosing Pumps, Not Operational**
```python
def test_runtime_tracking_excludes_operational_pumps():
    # Run mixing pump for 60 minutes
    run_mixing_pump(duration_minutes=60)

    # Run nutrient pump for 5 minutes
    run_nutrient_pump(duration_minutes=5)

    # Assert: only nutrient runtime counted
    assert get_dosing_runtime() == 5 * 60  # 300 seconds
    assert get_dosing_runtime() != 65 * 60  # Doesn't include mixing
```

#### Stuck Sensor Detection (3 tests)

**Test 20: EC Doesn't Increase After 1 Min Runtime â†’ Stop, Alert**
```python
def test_ec_no_increase_after_1min_stops_dosing(freezegun, mock_ec_sensor):
    # Arrange: EC stuck at 1.0
    mock_ec_sensor.ec = 1.0

    with freeze_time("2026-01-30 10:00:00") as frozen_time:
        # Dose for 20 seconds (EC still 1.0)
        start_nutrient_pumps()
        frozen_time.tick(delta=timedelta(seconds=20))
        stop_nutrient_pumps()

        # Dose again for 20 seconds (EC still 1.0)
        start_nutrient_pumps()
        frozen_time.tick(delta=timedelta(seconds=20))
        stop_nutrient_pumps()

        # Dose again for 21 seconds (total = 61 seconds, EC still 1.0)
        start_nutrient_pumps()
        frozen_time.tick(delta=timedelta(seconds=21))

        # Check stuck sensor detection
        result = check_for_stuck_ec_sensor()

        # Assert: detected stuck sensor (1 min runtime, no EC change)
        assert result.stuck_detected == True
        assert result.action == "stop_dosing_alert"
```

**Test 21: pH Doesn't Change After 1 Min Runtime â†’ Stop, Alert**
```python
def test_ph_no_change_after_1min_stops_dosing():
    # Same pattern as Test 20, for pH sensor
```

**Test 22: EC Increases â†’ Reset Stuck Counter**
```python
def test_ec_increase_resets_stuck_detection():
    # Dose 1: EC 1.0 â†’ 1.0 (30 sec)
    # Dose 2: EC 1.0 â†’ 1.2 (increase detected, counter resets)
    # Dose 3: EC 1.2 â†’ 1.2 (30 sec, counter = 30, not 60)

    assert stuck_sensor_counter == 30  # Reset after EC increased
```

#### Relay Verification (3 tests)

**Test 23: Send Pump OFF, Relay Still ON â†’ Emergency Shutdown**
```python
def test_stuck_relay_triggers_emergency_shutdown(mock_relay):
    # Arrange: pump running
    start_nutrient_pumps()

    # Simulate stuck relay
    mock_relay.set_relay("NutrientPumpA", False)
    mock_relay._force_state("NutrientPumpA", True)  # Stuck ON

    # Act: stop command sent
    stop_nutrient_pumps()

    # Verify relay state
    verify_relay_states()

    # Assert: emergency shutdown triggered
    assert emergency_shutdown_active() == True
```

**Test 24: Test All Dosing Pump Types**
```python
@pytest.mark.parametrize("pump_name", [
    "NutrientPumpA",
    "NutrientPumpB",
    "NutrientPumpC",
    "pHPlusPump",
    "pHMinusPump",
])
def test_relay_verification_all_dosing_pumps(pump_name, mock_relay):
    # Test stuck relay detection for each dosing pump type
```

**Test 25: Relay Readback Timeout â†’ Safe Default**
```python
def test_relay_readback_timeout_safe_default(mock_relay):
    # Simulate relay readback taking too long (Modbus timeout)
    mock_relay.get_relay_state.side_effect = TimeoutError()

    # Act: verify relay states
    result = verify_relay_states()

    # Assert: treat as unsafe, trigger shutdown
    assert result.safe == False
```

---

### File 3: test_system_safety.py (10 tests)

#### Multi-Sensor Failure (4 tests)

**Test 26: EC Invalid + pH Invalid â†’ Shutdown All Dosing**
```python
def test_multi_sensor_failure_triggers_shutdown(mock_ec_sensor, mock_ph_sensor):
    # Arrange: both sensors invalid
    mock_ec_sensor.ec = 0.0  # Below min (invalid)
    mock_ph_sensor.ph = None  # Sensor failed

    # Act: check system safety
    safety_check_result = perform_system_safety_check()

    # Assert: fail-safe shutdown
    assert safety_check_result.shutdown_triggered == True
    assert safety_check_result.reason == "multi_sensor_failure"
    assert all_dosing_stopped() == True
```

**Test 27: EC Invalid + Water Level Invalid â†’ Shutdown**
```python
def test_ec_and_water_level_failure_shutdown():
    # Similar pattern as Test 26
```

**Test 28: All Three Sensors Invalid â†’ Complete Shutdown**
```python
def test_all_sensors_invalid_complete_shutdown():
    # EC, pH, water level all invalid â†’ emergency mode
```

**Test 29: Emergency Flag Requires Manual Restart**
```python
def test_emergency_flag_blocks_auto_restart():
    # Trigger emergency shutdown
    trigger_emergency_shutdown(reason="multi_sensor_failure")

    # Attempt to restart automatically
    result = attempt_auto_restart()

    # Assert: refused, requires manual intervention
    assert result.allowed == False
    assert result.requires_manual == True
```

#### Invalid Config â†’ Safe Defaults (3 tests)

**Test 30: Negative Duration â†’ Use Default**
```python
def test_negative_duration_uses_default(tmp_path, monkeypatch):
    config_file = tmp_path / "device.conf"
    config_file.write_text("""
[NutrientPump]
nutrient_pump_on_duration = -00:05:00, -00:10:00
""")

    on, wait = get_nutrient_config()
    assert on == "00:00:00"  # Safe default (disabled)
```

**Test 31: Invalid ABC Ratio â†’ Use Default 1:1:0**
```python
@pytest.mark.parametrize("invalid_ratio", [
    "-1:1:0",
    "999:1:0",
    "a:b:c",
    "1:1",  # Missing third value
])
def test_invalid_abc_ratio_uses_default(invalid_ratio, tmp_path, monkeypatch):
    config_file = tmp_path / "device.conf"
    config_file.write_text(f"""
[NutrientPump]
nutrient_abc_ratio = 1:1:0, {invalid_ratio}
""")

    ratio = get_abc_ratio_from_config()
    assert ratio == [1, 1, 0]  # Safe default
```

**Test 32: Extreme EC/pH Targets â†’ Use Defaults**
```python
@pytest.mark.parametrize("invalid_target,expected_default", [
    ("5.0, 10.0", 1.2),  # EC > 3.0
    ("1.0, -2.0", 1.2),  # EC < 0
    ("6.5, 12.0", 6.5),  # pH > 9.0 (tested separately for pH)
])
def test_extreme_targets_use_defaults(invalid_target, expected_default):
    # Test both EC and pH target validation
```

#### Concurrent Scheduling (2 tests)

**Test 33: New Command During Critical Phase â†’ Reject**
```python
def test_new_command_rejected_during_critical_phase(mock_relay):
    # Arrange: dosing in progress (critical phase)
    start_nutrient_pumps()
    assert is_in_critical_phase() == True

    # Act: new manual dose command
    result = handle_new_dose_command()

    # Assert: rejected
    assert result.accepted == False
    assert result.reason == "critical_phase_locked"
```

**Test 34: New Command During Normal Phase â†’ Preempt**
```python
def test_new_command_preempts_during_normal_phase(mock_relay):
    # Arrange: waiting between cycles (normal phase)
    schedule_next_nutrient_cycle()
    assert is_in_critical_phase() == False

    # Act: new manual dose command
    result = handle_new_dose_command()

    # Assert: accepted, old cycle cancelled
    assert result.accepted == True
    assert result.action == "preempted_old_cycle"
    # Verify pumps were reset to OFF before new cycle
    assert pump_reset_to_off_called() == True
```

#### Crash Recovery (1 test)

**Test 35: Crash Recovery â†’ Reset to Config Defaults**
```python
def test_crash_recovery_resets_to_defaults(tmp_path, monkeypatch):
    # Arrange: config specifies pump defaults
    config_file = tmp_path / "device.conf"
    config_file.write_text("""
[NutrientPump]
default_state = off

[MixingPump]
default_state = on

[RecirculationPump]
default_state = on
""")

    # Simulate crash with pumps in random states
    mock_relay.set_relay("NutrientPumpA", True)  # Was ON before crash
    mock_relay.set_relay("MixingPump", False)   # Was OFF before crash

    # Act: system restart (crash recovery)
    perform_crash_recovery_startup()

    # Assert: all pumps reset to config defaults
    assert mock_relay.get_relay_state("NutrientPumpA") == False  # Config default: OFF
    assert mock_relay.get_relay_state("MixingPump") == True     # Config default: ON

    # Assert: 5 minute stabilization wait
    assert sensor_stabilization_timer_active() == True

    # Assert: scheduled jobs cleared
    assert len(scheduler.get_jobs()) == 0
```

---

## Implementation Requirements

### New Functions to Implement

**Sensor Validation:**
```python
def is_valid_ec(ec_value: float) -> bool:
    """Validate EC sensor reading"""
    if ec_value is None or not isinstance(ec_value, (int, float)):
        return False
    if math.isnan(ec_value) or math.isinf(ec_value):
        return False
    if ec_value < 0.01 or ec_value > 3.0:
        return False
    return True

def is_ec_change_valid(previous: float, current: float) -> bool:
    """Check if EC change is within valid range"""
    if previous is None or current is None:
        return False
    change = abs(current - previous)
    return change <= 0.5
```

**Runtime Tracking:**
```python
class DosingRuntimeTracker:
    """Track dosing pump runtime for overdose prevention"""

    def __init__(self, storage_path: str):
        self.storage_path = storage_path
        self.load_history()

    def add_dosing_event(self, pump_name: str, duration_seconds: int):
        """Record a dosing event"""
        pass

    def get_today_total_runtime(self) -> int:
        """Get total dosing runtime for today (seconds)"""
        pass

    def can_dose(self, planned_duration: int) -> bool:
        """Check if dosing is within daily limit"""
        return self.get_today_total_runtime() + planned_duration <= 3600  # 60 min
```

**Emergency Shutdown:**
```python
def trigger_emergency_shutdown(reason: str):
    """Trigger emergency shutdown and set flag"""
    # 1. Stop all dosing pumps immediately
    # 2. Set emergency flag (persistent)
    # 3. Log reason
    # 4. Block automatic restarts
    pass

def is_emergency_shutdown_active() -> bool:
    """Check if emergency shutdown flag is set"""
    pass

def clear_emergency_shutdown():
    """Manual API call to clear emergency flag"""
    pass
```

**Critical Phase Lock:**
```python
def is_in_critical_phase() -> bool:
    """Check if any dosing pump is actively running"""
    # Read relay states for all dosing pumps
    # Return True if any are ON
    pass

def can_accept_new_command() -> bool:
    """Check if new command can be accepted"""
    return not is_in_critical_phase()
```

---

## Success Criteria

### Coverage Goals
- **Phase 1+2:** 49 tests, ~72% coverage on nutrient_static.py
- **Phase 2.5:** 35 tests, **target 85%+ coverage on all *_static.py**
- **Total:** 84 tests, comprehensive failure mode coverage

### Safety Validation
âœ… All sensor failure modes tested
âœ… Overdose prevention validated
âœ… Emergency shutdown tested
âœ… Config validation complete
âœ… Crash recovery verified

### Production Readiness Checklist
- [ ] All 84 tests passing
- [ ] Emergency shutdown integration tested
- [ ] Runtime tracking persists correctly
- [ ] Multi-sensor failure triggers shutdown
- [ ] Relay verification catches stuck hardware
- [ ] Config validation prevents dangerous values
- [ ] Crash recovery resets to safe state

---

## Risk Matrix (What Phase 2.5 Prevents)

| Risk | Without Phase 2.5 | With Phase 2.5 |
|------|-------------------|----------------|
| Stuck EC sensor causes continuous dosing | âŒ Undetected, crops killed | âœ… Detected after 1 min, shutdown |
| Nutrient pump stuck ON | âŒ Runs indefinitely | âœ… Shutoff at 30 sec, emergency |
| Invalid EC reading (NaN) triggers dose | âŒ Crashes or doses incorrectly | âœ… Rejected, logged |
| Multi-sensor failure | âŒ Undefined behavior | âœ… Fail-safe shutdown |
| Crash leaves pumps ON | âŒ Pumps run until manual intervention | âœ… Reset to defaults on startup |
| Daily overdose from multiple cycles | âŒ No limit | âœ… 60 min daily max enforced |
| Bad config value | âŒ Crashes or dangerous operation | âœ… Safe defaults, logged |
| Concurrent commands | âŒ Race conditions | âœ… Critical lock + preemption |

---

## Implementation Order

1. **Sensor validation functions** (is_valid_ec, is_valid_ph, is_valid_water_level)
2. **Runtime tracker** (DosingRuntimeTracker class)
3. **Emergency shutdown system** (trigger, check, clear)
4. **Critical phase lock** (is_in_critical_phase)
5. **Stuck sensor detection** (track runtime vs. sensor response)
6. **Test file 1:** test_sensor_validation.py (12 tests)
7. **Test file 2:** test_overdose_prevention.py (13 tests)
8. **Test file 3:** test_system_safety.py (10 tests)
9. **Integration verification** (all 84 tests together)

---

## Notes

- Phase 2.5 is **NOT optional** for Â¥100,000 devices
- These tests prevent crop loss and equipment damage
- Focus on "what could go wrong" rather than "does it work when everything is fine"
- Every test represents a real failure mode that could occur in production
- Cost of implementing: ~2-3 days
- Cost of NOT implementing: potential Â¥100,000+ crop loss per incident
